[{"id":0,"href":"/docs/ETC/Algorithms/summary/","title":"알고리즘 공부 방향성","section":"Algorithms","content":"알고리즘 공부 방향성 #  💡 Summary #  [ 목적 ]\n 코딩테스트 더 효율적인 코드 구현 능력 향상 : “왜?”에 집중하여 학습하자 Snippet 만들기 : 깃허브 기스트  [ 기본서 ] 파이썬 알고리즘 인터뷰\n[ 언어 ] 파이썬\n[ 문제풀이 플랫폼 ] LeetCode\n 방향성 #   나의 1차적 목적은 코딩테스트이다.\n하지만 더 멀게는 효율적인 코드 구현 능력 향상을 목적으로하며 “왜?”에 집중하여 학습하고자 한다. 전체적으로 파이썬 알고리즘 인터뷰 책을 따라 학습하며\n(1) 개념 정리 (2) 실습 2가지로 정리한다.  실습 : LeetCode 총 95문제를 풀이 책 문제풀이 유튜브 책 깃허브 소스코드    참고 #   LeetCode 외 알고리즘 문제 풀이 플랫폼  Codility 해커랭크 프로그래머스 리모트인터뷰    "},{"id":1,"href":"/docs/ETC/Algorithms/LeetCode/234/","title":"[ LeetCode #234 ]","section":"LeetCode 실습","content":"[ LeetCode #234 ] Palindrome Linked List 팰린드롬 연결 리스트 #  [ LeetCode #234 ] Palindrome Linked List 바로가기  #  💡 유용한 지식 #  러너 기법\n 연결 리스트를 순회할 때 2개의 포인터를 동시에 사용하는 기법 빠른 러너와 느린 러너를 생성하여 병합 지점이나 중간 위치, 길이 등을 판별할 때 유용 빠른 러너가 연결 리스트의 끝에 도달하면 느린 러너는 연결 리스트의 중간 지점을 가리키게 되어 중간 위치를 찾아내면 값 비교하거나 뒤집기를 시도하는 등 다각도로 활용이 가능  ## runner 기법 # - fast, slow 는 모두 Linked List # - fast 에 값이 있다면 길이가 홀수인 경우이므로 한칸 더 전진시킨다. while fast and fast.next: fast = fast.next.next history, history.next, slow = slow, history, slow.next if fast: slow = slow.next 다중 할당 (Multiple Assignment)\n 파이썬은 원시 타입이 존재하지 않고 모든 것이 객체 줄을 구분해서 할당하면 history = slow 구문으로 인해 같은 객체를 참조를 할당하므로 줄을 나누는 것과 한번에 처리하는 것은 다른 풀이가 된다.  history, history.next, slow = slow, history, slow.next    문제 #  Given the head of a singly linked list, return true if it is a palindrome.\n Examples ↕  Example 1: Input: head = [1,2,2,1] Output: true Example 2: Input: head = [1,2] Output: false     Constraints:\n The number of nodes in the list is in the range [1, 105]. 0 \u0026lt;= Node.val \u0026lt;= 9  Follow up:\nCould you do it in O(n) time and O(1) space?\n 내가 했던 접근 #   실패 History ↕   linked list 개념을 잘 이해하지 못했으며 palindrome 판별이라는 것을 잊고 조금 헤맸다.     [ 풀이 ]\n 리스트에 append 후 슬라이싱으로 판별하기  [ 결과 ]\nRuntime: 1214 ms, faster than 68.41% of Python online submissions for Palindrome Linked List. Memory Usage: 85.6 MB, less than 17.58% of Python online submissions for Palindrome Linked List.\n[ 코드 ]\n# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def isPalindrome(self, head): history = list() if head.next is None: return True while head: history.append( head.val ) head = head.next return history == history[::-1] [ 반성 ]\n linked list 특성을 살리지 못한 풀이   책 풀이 #  [ 풀이 ]\n 방법 1 : list + pop(0) (내 접근과 유사)  나는 팰린드롬 판별을 리스트 슬라이싱으로 했지만 pop(0)을 사용   방법 2 : deque + popleft()  방법 1 은 pop(0) 으로 조회가 O(n)이었지만 데크 자료형으로 O(1)로 조회 가능   방법 3 : 러너 **  fast, slow 러너 2가지를 만들고 fast는 두칸씩, slow는 한칸씩 전진시켜 fast가 끝에 도달할때 slow를 중간지점에 위치시킨다. slow가 오면서 지나친 길을 역순으로 history를 만들고 만약 길이가 홀수였으면 slow 를 한칸 더 전진 시킨다. slow의 중간을 지나친 값과 역순으로 기록해둔 history의 값을 차례로 비교한다. 모두 일치하여 slow가 None이 되면 True, 아니면 False 반환    [ 결과 ]\n방법 1 : list + pop(0) (내 접근과 유사)\nRuntime: 1690 ms, faster than 23.68% of Python online submissions for Palindrome Linked List.\nMemory Usage: 84.7 MB, less than 46.59% of Python online submissions for Palindrome Linked List.\n방법 2 : deque + popleft()\nRuntime: 1469 ms, faster than 41.47% of Python online submissions for Palindrome Linked List. Memory Usage: 84.5 MB, less than 51.87% of Python online submissions for Palindrome Linked List.\n방법 3 : (연결리스트 특성 활용한 방법) 러너 (992 ms)**\nRuntime: 992 ms, faster than 93.93% of Python online submissions for Palindrome Linked List.\nMemory Usage: 49.6 MB, less than 96.18% of Python online submissions for Palindrome Linked List.\n[ 코드 ]\n방법 1 : list + pop(0) (1690 ms)\nclass Solution(object): def isPalindrome(self, head): history = list() if head.next is None: return True while head: history.append( head.val ) head = head.next while len(history) \u0026gt; 1 : if history.pop(0) != history.pop(): return False return True 방법 2 : deque + popleft() (1469 ms)\nfrom collections import deque class Solution(object): def isPalindrome(self, head): history = deque() if head.next is None: return True while head: history.append( head.val ) head = head.next while len(history) \u0026gt; 1 : if history.popleft() != history.pop(): return False return True 방법 3 : (연결리스트 특성 활용한 방법) 러너 (992 ms)**\nclass Solution(object): def isPalindrome(self, head): history = None fast = slow = head while fast and fast.next: fast = fast.next.next history, history.next, slow = slow, history, slow.next if fast: slow = slow.next while history and history.val == slow.val: history, slow = history.next, slow.next return not slow "},{"id":2,"href":"/docs/ETC/Algorithms/LeetCode/1/","title":"[ LeetCode #1 ]","section":"LeetCode 실습","content":"[ LeetCode #1 ] Two Sum 두 수의 합 #  [ LeetCode #1 ] Two Sum 바로가기  #  💡 유용한 지식 #  index() 함수 start, end 인자\n## index()함수 인자 # - start, end ; (optional)조회하려는 리스트 시작과 끝 인덱스 index(value, start, end) Dictionary 의 조회는 O(1)\n 키/값 구조로 이루어져 있으며 입력 순서가 유지(버전 3.7이상)되며 내부적으로는 해시 테이블로 구현되어 있다. 다양한 타입을 키로 지원하면서도 입력과 조회 모두 분할 상환 분석에 따른 시간 복잡도는 O(1)로 가능하다.(최악의 경우엔 O(n))    연산 시간 복잡도     len(a) O(1)   a[key] O(1)   a[key] = value O(1)   key in a O(1)        문제 #  Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n Examples ↕  Example 1:\nInput: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2:\nInput: nums = [3,2,4], target = 6 Output: [1,2] Example 3:\nInput: nums = [3,3], target = 6 Output: [0,1]     Constraints:\n 2 \u0026lt;= nums.length \u0026lt;= 104 109 \u0026lt;= nums[i] \u0026lt;= 109 109 \u0026lt;= target \u0026lt;= 109 Only one valid answer exists.  Follow-up:\nCan you come up with an algorithm that is less than O(n^2) time complexity?\n 내가 했던 접근 #  [ 풀이 ]\n num 앞에서부터 읽으면서 target - num 이 num의 index 뒤에 있는지 판별 후 있으면 리턴  [ 결과 ]\nRuntime: 573 ms, faster than 49.33% of Python online submissions for Two Sum. Memory Usage: 14.1 MB, less than 87.35% of Python online submissions for Two Sum.\n[ 코드 ]\nclass Solution(object): def twoSum(self, nums, target): for ind, num in enumerate(nums): sub_target = target - num if sub_target in nums[ind+1:]: sub_ind = nums.index(sub_target, ind+1, len(nums)) return [ind, sub_ind] [ 반성 ]\n 복잡도 O(n^2) 인 것 같다. 더 나은 방법 있을 것 같다.   책 풀이 #  [ 풀이 ]\n 방법 1 : 부르트포스  이중 for 문으로 앞에서부터 전체 탐색 복잡도 O(n^2)   방법 2 : in 활용 ( 내 접근과 유사 )  방법 1과 동일하지만 in 활용 복잡도 O(n^2) 로 동일하지만 훨씬 빠르다.   방법 3 : 딕셔너리 활용 **  딕셔너리의 조회가 O(1)인 점을 이용하여 dictionary에 값의 index를 저장해두면서 target - num을 조회   만약 정렬된 리스트라면 투포인터 방법도 좋았겠지만, 정렬에도 시간이 쓰이고 문제가 인덱스 반환이라 불가능했다.  [ 결과 ]\n방법 1 : 브루트포스 (5294 ms)\nRuntime: 5294 ms, faster than 12.44% of Python online submissions for Two Sum. Memory Usage: 14.4 MB, less than 46.22% of Python online submissions for Two Sum.\n방법 2 : in 활용(내 접근과 유사) (463 ms)\nRuntime: 463 ms, faster than 52.12% of Python online submissions for Two Sum. Memory Usage: 13.9 MB, less than 97.93% of Python online submissions for Two Sum.\n방법 3 : 딕셔너리 활용 (36ms) **\nRuntime: 36 ms, faster than 99.52% of Python online submissions for Two Sum. Memory Usage: 13.9 MB, less than 99.01% of Python online submissions for Two Sum.\n[ 코드 ]\n방법 1 : 브루트포스 (5294 ms)\nclass Solution(object): def twoSum(self, nums, target): for i in range(len(nums)): for j in range(i+1,len(nums)): if nums[i] + nums[j] == target: return [i, j] 방법 2 : in 활용(내 접근과 유사) (463 ms)\nclass Solution(object): def twoSum(self, nums, target): for i, num in enumerate(nums): sub_target = target - num if sub_target in nums[i+1:]: return [nums.index(num) , nums[i+1:].index(sub_target)+(i+1)] ## 내 풀이와 다른 점 : index() 찾는법 # 내 방법 : index()함수에서 start, end 활용 nums.index(sub_target, ind+1, len(nums)) # 책 풀이 : 이전 탐색 index 이후 리스트에서 찾기 nums[i+1:].index(sub_target)+(i+1) 방법 3 : 딕셔너리 활용 (36ms) **\nclass Solution(object): def twoSum(self, nums, target): index_dict = dict() for i, num in enumerate(nums): sub_target = target - num if sub_target in index_dict: return [index_dict[sub_target], i] index_dict[num] = i "},{"id":3,"href":"/docs/ETC/Algorithms/LeetCode/5/","title":"[ LeetCode #5 ]","section":"LeetCode 실습","content":"[ LeetCode #5 ] Longest Palindrome Substring 가장 긴 팰린드롬 부분 문자열 #  [ LeetCode #5 ] Longest Palindromic Substring 바로가기  #  💡 유용한 지식 #  max() 함수 key 활용\nmax( result, two_pointer(i, i+1), two_pointer(i, i+2), key = len) 투포인터 좁히는 방향이 아닌 확장하며 탐색\ndef two_pointer(left, right): while left \u0026gt;= 0 and right \u0026lt; len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right]    문제 #  Given a string s, return the longest palindromic substring in s.\n Examples ↕  **Example 1:** ``` Input: s = \u0026quot;babad\u0026quot; Output: \u0026quot;bab\u0026quot; Explanation: \u0026quot;aba\u0026quot; is also a valid answer. ``` **Example 2:** ``` Input: s = \u0026quot;cbbd\u0026quot; Output: \u0026quot;bb\u0026quot; ```     Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 1000 s consist of only digits and English letters.   내가 했던 접근 #  [ 풀이(실패) ]\n 1차 시도 : ‘가장 긴' 팰린드롬을 찾아야했기 때문에 전체 문자열부터 하나씩 길이를 줄여가며 탐색하는 방향으로 잡았다. 따라서 하나씩 길이를 줄여가면서 문자열이 팰린드롬인지 탐색했다. 2차 시도 : 1차 시도에 투포인터 방법을 적용해봤지만 여전히 시간초과로 실패하였다.  [ 결과 ] Time Limit Exceed\n[ 코드 ]\n1차 시도\nclass Solution(object): def longestPalindrome(self, s): len_sub = 0 while True: for ind in range(len_sub+1): new_s = s[ind:len(s)-(len_sub-ind)] if new_s == new_s[::-1]: return new_s len_sub +=1 2차 시도\nclass Solution(object): def groupAnagrams(self, strs): groups = dict() for string in strs: sorted_string = \u0026#39;\u0026#39;.join(sorted(string)) if sorted_string in groups.keys(): groups[sorted_string].append(string) else: groups[sorted_string] = [string] return list(groups.values()) [ 반성 ]\n 시간 복잡도가 너무 큰 방법으로, 처음에 전체 문자열부터 차츰 길이를 줄여가는 접근부터가 잘못됐다.   책 풀이 #  [ 풀이 ]\n 크게 문자열의 길이가 짝수인 경우 홀수인 경우 2가지만 존재 맨 앞에서부터 짝수인 경우 홀수인 경우로 나눠 가장 짧은 길이인 2, 3일때 투포인터로 팰린드롬 판별 만약 팰린드롬이 맞으면 포인터를 왼쪽은 왼쪽, 오른쪽은 오른쪽으로 확장해서 가장 긴 팰린드롬을 찾는다. 가장 긴 팰린드롬을 저장해두고 인덱스를 넓혀가며 반복한다.  [ 결과 ]\nRuntime: 809 ms, faster than 85.78% of Python online submissions for Longest Palindromic Substring.\nMemory Usage: 13.5 MB, less than 70.60% of Python online submissions for Longest Palindromic Substring.\n[ 코드 ]\nclass Solution(object): def longestPalindrome(self, s): def two_pointer(left, right): while left \u0026gt;= 0 and right \u0026lt; len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] if len(s) \u0026lt;= 1: return s result = \u0026#39;\u0026#39; for i in range(len(s)+1): result = max( result, two_pointer(i, i+1), two_pointer(i, i+2), key = len) return result "},{"id":4,"href":"/docs/ETC/Algorithms/LeetCode/49/","title":"[ LeetCode #49 ]","section":"LeetCode 실습","content":"[ LeetCode #49 ] Group Anagrams 그룹 애너그램 #  [ LeetCode #49 ] Group Anagrams 바로가기  #  💡 유용한 지식 #  Dictionary defaultdict 객체\n 존재하지 않는 키를 조회할 경우 에러 메시지 대신 디폴트 값을 기준으로 키에 대한 딕셔너리 아이템을 생성해줌  # defaultdict() 사용으로 불필요한 if 연산 제거 from collections import defaultdict groups = defaultdict(list)    문제 #  Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n Examples ↕  **Example 1:** ``` Input: strs = [\u0026quot;eat\u0026quot;,\u0026quot;tea\u0026quot;,\u0026quot;tan\u0026quot;,\u0026quot;ate\u0026quot;,\u0026quot;nat\u0026quot;,\u0026quot;bat\u0026quot;] Output: [[\u0026quot;bat\u0026quot;],[\u0026quot;nat\u0026quot;,\u0026quot;tan\u0026quot;],[\u0026quot;ate\u0026quot;,\u0026quot;eat\u0026quot;,\u0026quot;tea\u0026quot;]] ``` **Example 2:** ``` Input: strs = [\u0026quot;\u0026quot;] Output: [[\u0026quot;\u0026quot;]] ``` **Example 3:** ``` Input: strs = [\u0026quot;a\u0026quot;] Output: [[\u0026quot;a\u0026quot;]] ```     Constraints:\n 1 \u0026lt;= strs.length \u0026lt;= 104 0 \u0026lt;= strs[i].length \u0026lt;= 100 strs[i] consists of lowercase English letters.   내가 했던 접근 #   실패 History ↕     [ 풀이 ]\n input 단어를 각각 sorted() 후 동일한 단어끼리 딕셔너리로 그룹을 묶고 values() 로 결과 반환  [ 결과 ]\nRuntime: 1956 ms, faster than 7.46% of Python online submissions for Group Anagrams.\nMemory Usage: 17.3 MB, less than 83.24% of Python online submissions for Group Anagrams.\n[ 코드 ]\nclass Solution(object): def groupAnagrams(self, strs): groups = dict() for string in strs: sorted_string = \u0026#39;\u0026#39;.join(sorted(string)) if sorted_string in groups.keys(): groups[sorted_string].append(string) else: groups[sorted_string] = [string] return list(groups.values()) [ 반성 ]\n dict() 대신 collections.defaultdict(list) 사용하면 불필요한 if문 제거 가능   책 풀이 #  [ 풀이 ]\n 내 접근과 동일하지만 dict() 대신 collections.defaultdict(list) 사용하여 불필요한 if문 제거 가능  [ 결과 ]\nRuntime: 117 ms, faster than 58.08% of Python online submissions for Group Anagrams.\nMemory Usage: 17.6 MB, less than 71.25% of Python online submissions for Group Anagrams.\n[ 코드 ]\nfrom collections import defaultdict class Solution(object): def groupAnagrams(self, strs): groups = defaultdict(list) for string in strs: groups[\u0026#39;\u0026#39;.join(sorted(string))].append(string) return list(groups.values()) "},{"id":5,"href":"/docs/ETC/Algorithms/LeetCode/819/","title":"[ LeetCode #819 ]","section":"LeetCode 실습","content":"[ LeetCode #819 ] Most Common Word 가장 흔한 단어 #  [ LeetCode #819 ] Most Common Word 바로가기  #  💡 유용한 지식 #  Dictionary TIPS!\n# 빈도 세기 from collections import Counter count_dict = Counter(re.sub(\u0026#39;[^a-z0-9]\u0026#39;,\u0026#39; \u0026#39;,paragraph.lower()).split()) # key 삭제 for word in banned: del count_dict[word] # 가장 높은 빈도 추출 : most_common() # - (0)이 아닌 (1) 이 가장 높은 빈도 # - return = (key,value) count_dict.most_common(1)[0][0] # defaultdict() 사용으로 불필요한 if 연산 제거 from collections import defaultdict groups = defaultdict(list)   문제 #  Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\n Examples ↕  Example 1:\nInput: paragraph = \u0026quot;Bob hit a ball, the hit BALL flew far after it was hit.\u0026quot;, banned = [\u0026quot;hit\u0026quot;] Output: \u0026quot;ball\u0026quot; Explanation: \u0026quot;hit\u0026quot; occurs 3 times, but it is a banned word. \u0026quot;ball\u0026quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as \u0026quot;ball,\u0026quot;), and that \u0026quot;hit\u0026quot; isn't the answer even though it occurs more because it is banned. Example 2:\nInput: paragraph = \u0026quot;a.\u0026quot;, banned = [] Output: \u0026quot;a\u0026quot;     Constraints:\n 1 \u0026lt;= paragraph.length \u0026lt;= 1000 paragraph consists of English letters, space ' ', or one of the symbols: \u0026quot;!?',;.\u0026quot;. 0 \u0026lt;= banned.length \u0026lt;= 100 1 \u0026lt;= banned[i].length \u0026lt;= 10 banned[i] consists of only lowercase English letters.  내가 했던 접근 #   실패 History ↕     [ 풀이 ]\n input 읽으면서 클렌징하고 Counter() 함수로 단어별 빈도 딕셔너리 생성 banned 리스트 읽으면서 딕셔너리에서 key 삭제 딕셔너리의 most_common() 함수 활용하여 결과 반환  [ 결과 ]\nRuntime: 32 ms, faster than 65.55% of Python online submissions for Most Common Word.\nMemory Usage: 13.7 MB, less than 39.48% of Python online submissions for Most Common Word.\n[ 코드 ]\nfrom collections import Counter import re class Solution(object): def mostCommonWord(self, paragraph, banned): count_dict = Counter(re.sub(\u0026#39;[^a-z0-9]\u0026#39;,\u0026#39; \u0026#39;,paragraph.lower()).split()) for word in banned: del count_dict[word] return count_dict.most_common(1)[0][0] [ 반성 ]\n Counter 딕셔너리를 모두 생성 후 banned 리스트 단어를 삭제하는데 클렌징 과정에서 banned 리스트 단어를 삭제하면서 Counter 딕셔너리 생성 가능  책 풀이 #  [ 풀이 ]\n 내 접근과 동일하지만 input 클렌징시 banned 단어 삭제  [ 결과 ]\nRuntime: 39 ms, faster than 45.79% of Python online submissions for Most Common Word.\nMemory Usage: 13.6 MB, less than 66.92% of Python online submissions for Most Common Word.\n[ 코드 ]\nfrom collections import Counter import re class Solution(object): def mostCommonWord(self, paragraph, banned): words = [word for word in re.sub(\u0026#39;[^\\w]\u0026#39;,\u0026#39; \u0026#39;,paragraph.lower()).split() if word not in banned] count_dict = Counter(words) return count_dict.most_common(1)[0][0] "},{"id":6,"href":"/docs/ETC/Algorithms/LeetCode/937/","title":"[ LeetCode #937 ]","section":"LeetCode 실습","content":"[ LeetCode #937 ] Reorder Log Files 로그 파일 재정렬 #  [ LeetCode #937 ] Reorder Log Files 바로가기  #  💡 유용한 지식 #  리스트 정렬\n# 리스트 정렬 index 반환 index = sorted(range(len(s)), key = lambda x : s[x]) s = [s[i] for i in index] # string split list로 sort s.sort(key = lambda x: (x.split(\u0026#39; \u0026#39;)[1:], x.split(\u0026#39; \u0026#39;)[0])) # 함수를 이용한 sorting def fn(s): return s[0], s[-1] sorted(a, key=fn) sorted(a, key=len)   문제 #  You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.\nThere are two types of logs:\n Letter-logs: All words (except the identifier) consist of lowercase English letters. Digit-logs: All words (except the identifier) consist of digits.  Reorder these logs so that:\n The letter-logs come before all digit-logs. The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers. The digit-logs maintain their relative ordering.  Return the final order of the logs.\n Examples ↕  **Example 1:** ``` Input: logs = [\u0026quot;dig1 8 1 5 1\u0026quot;,\u0026quot;let1 art can\u0026quot;,\u0026quot;dig2 3 6\u0026quot;,\u0026quot;let2 own kit dig\u0026quot;,\u0026quot;let3 art zero\u0026quot;] Output: [\u0026quot;let1 art can\u0026quot;,\u0026quot;let3 art zero\u0026quot;,\u0026quot;let2 own kit dig\u0026quot;,\u0026quot;dig1 8 1 5 1\u0026quot;,\u0026quot;dig2 3 6\u0026quot;] Explanation: The letter-log contents are all different, so their ordering is \u0026quot;art can\u0026quot;, \u0026quot;art zero\u0026quot;, \u0026quot;own kit dig\u0026quot;. The digit-logs have a relative order of \u0026quot;dig1 8 1 5 1\u0026quot;, \u0026quot;dig2 3 6\u0026quot;. ``` **Example 2:** ``` Input: logs = [\u0026quot;a1 9 2 3 1\u0026quot;,\u0026quot;g1 act car\u0026quot;,\u0026quot;zo4 4 7\u0026quot;,\u0026quot;ab1 off key dog\u0026quot;,\u0026quot;a8 act zoo\u0026quot;] Output: [\u0026quot;g1 act car\u0026quot;,\u0026quot;a8 act zoo\u0026quot;,\u0026quot;ab1 off key dog\u0026quot;,\u0026quot;a1 9 2 3 1\u0026quot;,\u0026quot;zo4 4 7\u0026quot;] ```     Constraints:\n 1 \u0026lt;= logs.length \u0026lt;= 100 3 \u0026lt;= logs[i].length \u0026lt;= 100 All the tokens of logs[i] are separated by a single space. logs[i] is guaranteed to have an identifier and at least one word after the identifier  내가 했던 접근 #   실패 History ↕   content가 동일하면 identifiers 순으로 sorting 예외처리 안함  class Solution(object): def reorderLogFiles(self, logs): letter_logs = [] digit_logs = [] for log in logs: if log.split(\u0026#39; \u0026#39;)[1].isnumeric(): digit_logs.append(log) else: letter_logs.append(log) letter_logs2 = list(map(lambda x: \u0026#39; \u0026#39;.join(x.split(\u0026#39; \u0026#39;)[1:]),letter_logs)) sort_index = sorted(range(len(letter_logs2)) , key = lambda x: letter_logs2[x]) letter_logs = [letter_logs[i] for i in sort_index] return letter_logs + digit_logs     [ 풀이 ]\n log 맨 앞 identifier 다음 단어가 letter인지 digit 판별하여 각각 별도 리스트로 저장 letter 인 리스트 sort하면서 index 를 반환받아서 letter log 재정렬 마지막 결과로 letter + digit 반환  [ 결과 ]\nRuntime: 43 ms, faster than 29.75% of Python online submissions for Reorder Data in Log Files.\nMemory Usage: 13.8 MB, less than 23.66% of Python online submissions for Reorder Data in Log Files.\n[ 코드 ]\nclass Solution(object): def reorderLogFiles(self, logs): letter_logs = [] digit_logs = [] for log in logs: if log.split(\u0026#39; \u0026#39;)[1].isnumeric(): digit_logs.append(log) else: letter_logs.append(log) sort_index = sorted(range(len(letter_logs)), key = lambda x: (\u0026#39; \u0026#39;.join(letter_logs[x].split(\u0026#39; \u0026#39;)[1:]), letter_logs[x].split(\u0026#39; \u0026#39;)[0])) letter_logs = [letter_logs[i] for i in sort_index] return letter_logs + digit_logs [ 반성 ]\n 굳이 index, join()해서 string으로 변환할 필요 없음, list 그대로 sort 가능  ## 굳이 index, join()해서 string으로 변환할 필요 X, list 그대로 sort 가능하다 sort_index = sorted(range(len(letter_logs)), key = lambda x: (\u0026#39; \u0026#39;.join(letter_logs[x].split(\u0026#39; \u0026#39;)[1:]), letter_logs[x].split(\u0026#39; \u0026#39;)[0])) letter_logs = [letter_logs[i] for i in sort_index] ## 이런식으로 letter_logs.sort(key = lambda x : (x.split(\u0026#39; \u0026#39;)[1:], x.split(\u0026#39; \u0026#39;)[0])) 책 풀이 #  [ 풀이 ]\n 내 접근과 동일하지만 letter 정렬시 index가 아닌 직접 sort 함수 적용  [ 결과 ]\nRuntime: 38 ms, faster than 44.80% of Python online submissions for Reorder Data in Log Files.\nMemory Usage: 13.7 MB, less than 77.18% of Python online submissions for Reorder Data in Log Files.\n[ 코드 ]\nclass Solution(object): def reorderLogFiles(self, logs): letter_logs = [] digit_logs = [] for log in logs: if log.split(\u0026#39; \u0026#39;)[1].isdigit(): digit_logs.append(log) else: letter_logs.append(log) letter_logs.sort(key = lambda x : (x.split(\u0026#39; \u0026#39;)[1:], x.split(\u0026#39; \u0026#39;)[0])) return letter_logs + digit_logs "},{"id":7,"href":"/docs/ETC/Algorithms/LeetCode/344/","title":"[ LeetCode #344 ]","section":"LeetCode 실습","content":"[ LeetCode #344 ] Reverse String 문자열 뒤집기 #  [ LeetCode #344 ] Reverse String 바로가기  #  💡 유용한 지식 #  리스트 역순으로 정렬\n# reverse() 함수 활용 s.reverse() # 슬라이싱 방법 활용 s = s[::-1] s[:] = s[::-1] # 투포인터를 활용하는 방법도 있다. def reverseString(s): left, right = 0, len(s)-1 while left \u0026lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 return s   문제 #  Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.\n Examples ↕  Example 1:\nInput: s = [\u0026quot;h\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;o\u0026quot;] Output: [\u0026quot;o\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;h\u0026quot;] Example 2:\nInput: s = [\u0026quot;H\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;h\u0026quot;] Output: [\u0026quot;h\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;H\u0026quot;]     Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 105 s[i] is a printable ascii character.  내가 했던 접근 #   실패 History ↕   슬라이싱을 활용하여 s[::-1] 만으로 제출하려했지만 O(1) 의 메모리 공간만 허용해서 불가능했다.     [ 풀이 ]\n메모리 공간이 O(1) 만 있으므로 끝에서부터 pop()하여 맨 앞에 insert() 수행\n[ 결과 ]\nRuntime: 628 ms, faster than 5.01% of Python online submissions for Reverse String.\nMemory Usage: 22 MB, less than 7.54% of Python online submissions for Reverse String.\n[ 코드 ]\nclass Solution(object): def reverseString(self, s): for i in range(len(s)-1): s.insert(i, s.pop()) return s ## 초기 생각 : 슬라이싱 s[::-1] [ 반성 ]\n 처음에는 슬라이싱으로 해결하려했지만 extra memory O(1)을 간과했다. 따라서 insert로 접근 새로 리스트 만드는건 물론 더 메모리를 잡아먹으므로 불가능 메모리에만 집중해서 시간복잡도는 생각을 못했다.  책 풀이 #  [ 풀이 ]\n 총 3가지 방법 소개  방법 1 : 투포인터 방법 2 : Pythonic 방법, reverse() 활용 방법 3 : Pythonic 방법, 슬라이싱 활용    [ 결과 ]\n방법 1 : 투포인터\nRuntime: 215 ms, faster than 55.01% of Python online submissions for Reverse String.\nMemory Usage: 21 MB, less than 81.03% of Python online submissions for Reverse String.\n방법 2 : Pythonic 방법, reverse() 활용\nRuntime: 162 ms, faster than 95.45% of Python online submissions for Reverse String.\nMemory Usage: 21.3 MB, less than 29.73% of Python online submissions for Reverse String.\n방법 3 : Pythonic 방법, 슬라이싱 활용\nRuntime: 164 ms, faster than 95.03% of Python online submissions for Reverse String.\nMemory Usage: 20.9 MB, less than 94.74% of Python online submissions for Reverse String.\n[ 코드 ]\n방법 1 : 투포인터\nclass Solution(object): def reverseString(self, s): left, right = 0, len(s)-1 while left \u0026lt; right: s[left],s[right] = s[right], s[left] left += 1 right -= 1 return s 방법 2 : Pythonic 방법, reverse() 활용\nclass Solution(object): def reverseString(self, s): s.reverse() return s 방법 3 : Pythonic 방법, 슬라이싱 활용\nclass Solution(object): def reverseString(self, s): s[:] = s[::-1] return s # s = s[::-1] 을 사용하면 메모리가 부족하지만 # s[:] = s[::-1] 을 사용하면 된다. "},{"id":8,"href":"/docs/ETC/Algorithms/LeetCode/125/","title":"[ LeetCode #125 ]","section":"LeetCode 실습","content":"[ LeetCode #125 ] Valid Palindrom 유효한 팰린드롬 #  [ LeetCode #125 ] Valid Palindrome 바로가기  #  💡 유용한 지식 #  ‘팰린드롬’ 이란?\n 앞뒤가 똑같은 단어나 문장으로, 뒤집어도 같은말이 되는 단어 또는 문장  리스트 pop(0) 과 데크 popleft()\n 리스트 pop(0) 이 O(n) 인데 반해 deque popleft() 가 O(1) 이기 때문에 n번씩 반복하면 리스트는 O(n2), deque 구현은 O(n)으로 성능 차이가 크다.  문자열 슬라이싱\n 슬라이싱은 내부적으로 C로 구현되어 있어서 더 빠르다. 위치를 지정하면 해당 위치의 배열 포인터를 얻게 되며 이를 통해 연결된 객체를 찾아 실제 값을 찾아내어 슬라이싱 사용시 속도 개선에 유리하다.  문자열 판별 함수\nstring.isalnum() ## alphanumeric 판별 string.isalpha() ## alphabet 판별 # 파이썬의 숫자 판별함수; 포함 범위 : numeric \u0026gt; digit \u0026gt; decimal string.isnumeric() ## numeric 판별 string.isdigit() string.isdecimal()  문자열 숫자 판별 함수 비교 : isnumeric() \u0026gt; isdigit() \u0026gt; isdecimal() ↕   isdigit()  특수 기호 중에서 어깨위에 제곱이나 세제곱을 표시하는 문자가 있다. digit은 이렇게 ‘숫자처럼 생긴’ 모든 글자를 다 숫자로 치는 것이다.   isnumeric()  numeric 하다는 것은 보다 넓은 의미인데, isdigit()은 단일 글자가 ‘숫자’ 모양으로 생겼으면 True를 리턴한다고 했다. isnumeric()은 숫자값 표현에 해당하는 텍스트까지 인정해준다. 예를 들어 “½” 이런 특수문자도 isnumeric()에서는 True로 판정된다.   isdecimal()  이것이 우리가 흔히 생각하는 ‘숫자’와 같은 개념이다. 즉 \u0026lsquo;0123456789\u0026rsquo;의 구성으로 이루어진 10개의 글자. 말 그대로 int 타입으로 즉시 변환이 가능한 리터럴을 구성하는 문자    \u0026lt;/div\u0026gt;     문자열을 alphanumeric 으로만 클린징하는 방법 시간 비교 ↕      문제 #  A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\nGiven a string s, return true if it is a palindrome, or false otherwise.\n Examples ↕  Example 1:\nInput: s = \u0026quot;A man, a plan, a canal: Panama\u0026quot; Output: true Explanation: \u0026quot;amanaplanacanalpanama\u0026quot; is a palindrome. Example 2:\nInput: s = \u0026quot;race a car\u0026quot; Output: false Explanation: \u0026quot;raceacar\u0026quot; is not a palindrome. Example 3:\nInput: s = \u0026quot; \u0026quot; Output: true Explanation: s is an empty string \u0026quot;\u0026quot; after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome.     Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 2 * 105 s consists only of printable ASCII characters.  내가 했던 접근 #   실패 History ↕   리스트 컴프리헨션 안에 else ‘’ 가 아닌 None 으로 해서 그냥 틀린 답안을 제출함     [ 풀이 ]\nalphanumeric 판별을 input을 차례로 읽으면서 직접 비교하였고 팰린드롬은 list의 슬라이싱으로 판별\n[ 결과 ]\nRuntime: 56 ms, faster than 59.39% of Python online submissions.\nMemory Usage: 16 MB, less than 14.33% of Python online submissions.\n[ 코드 ]\nclass Solution(object): def isPalindrome(self, s): alphabet= \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; numeric= \u0026#39;0123456789\u0026#39; new_s = \u0026#39;\u0026#39;.join([char.lower() if char in alphabet \\ else (char if char in numeric else \u0026#39;\u0026#39;)\\ for char in s ]) if new_s[::-1] == new_s: return True else: return False [ 반성 ]\n 과도한 리스트 컴프리헨션으로 가독성이 다소 떨어지는 것 같다. 사실 처음에 문제를 자세하게 정독하지 않고 ‘alphanumeric’이 아닌 알파벳으로만 생각해서 풀었다. 시간과 공간 효율이 좋지 못한 알고리즘인 것 같다. return이 True, False라면 if문 없이 더 간결하게 표현 가능하다.  책 풀이 #  [ 풀이 ]\n input string 을 읽어들이면서 alphanumeric을 판별하는 방식 3가지 (1) list 와 isalnum() (2) deque 와 isalnum() (3) re 정규표현식 활용 팰린드롬 판별 3가지 (1) list 의 pop() (2) deque 의 popleft() (3) list의 슬라이싱 위의 방법을 조합하여 총 3가지 방법 소개  방법 1 : list + isalnum() + pop() 방법 2 : deque + isalnum() + popleft() 방법 3 : re + list 슬라이싱    [ 결과 ]\n방법 1 : list + isalnum() + pop()\nRuntime: 276 ms, faster than 29.50% of Python online submissions for Valid Palindrome.\nMemory Usage: 15.2 MB, less than 37.33% of Python online submissions for Valid Palindrome.\n방법 2 : deque + isalnum() + popleft()\nRuntime: 40 ms, faster than 85.54% of Python online submissions for Valid Palindrome.\nMemory Usage: 14.8 MB, less than 53.26% of Python online submissions for Valid Palindrome.\n방법 3 : re + list 슬라이싱\nRuntime: 38 ms, faster than 87.41% of Python online submissions for Valid Palindrome.\nMemory Usage: 15.9 MB, less than 15.82% of Python online submissions for Valid Palindrome.\n[ 코드 ]\n방법 1 : list + isalnum() + pop()\nclass Solution(object): def isPalindrome(self, s:str)-\u0026gt; bool: str_list = [] for char in s: if char.isalnum(): str_list.append(char.lower()) while len(str_list)\u0026gt;1: if str_list.pop(0) != str_list.pop(): return False return True 방법 2 : deque + isalnum() + popleft()\nclass Solution(object): def isPalindrome(self, s:str)-\u0026gt; bool: str_list = [] for char in s: if char.isalnum(): str_list.append(char.lower()) while len(str_list)\u0026gt;1: if str_list.pop(0) != str_list.pop(): return False return True 방법 3 : re + list 슬라이싱\nimport re class Solution(object): def isPalindrome(self, s): s = s.lower() new_s = re.sub(\u0026#39;[^a-z0-9]\u0026#39;,\u0026#39;\u0026#39;,s) return new_s[::-1] == new_s "},{"id":9,"href":"/docs/bigdata_platform/Hadoop/hadoop_install_M1/","title":"[M1] Mac OS에 하둡(Hadoop) 설치","section":"Hadoop","content":"[M1] Mac OS에 하둡(Hadoop) 설치 #  설치 개요 #  [ 설치 목적 ] 하둡의 맵리듀스와 분산 파일 시스템인 HDFS를 경험해보자!\n[ 설치 환경 ]\nOS : [M1] MacOS Monterey 12.0.1\nHadoop : 3.3.2\n[ 기초 배경지식 ]\n하둡 맵리듀스는 수천개의 노드로 구성된 클러스터에서 병렬로 데이터를 처리하는 오픈소스 프레임워크이다. 하지만 개인이 클러스터 환경을 갖추기 어려우니, 하둡에서 Single node 설치 방법을 제공해준다.\n[ 설치 링크 ]\n(1) Cluster Setup\n(2) Single Node Setup\n나는 Single Node Setup을 따르며\n(1) Local (Standalone) Mode (2) Pseudo-Distributed Mode (3) Fully-Distributed Mode\n3가지 모드 중 Pseudo-Distributed Mode 로 설치하며 Yarn 사용을 위한 세팅도 진행한다.\n[ 사전 체크 항목 ]\nSupported platforms : 기본적으로 Linux/GNU/Window 지원\nRequired software :\n(1) 지원 Java 버전 설치 : Java 8 과 11 지원하지만, compile시 Java 11은 지원하지 않는다.\n(2) ssh 설치\n  ssh 설치 여부 및 권한 확인 ↕  ssh localhost ## 터미널에서 ssh 설치 여부 확인 [ Troubleshooting #1 ] : Connection refused\n아래와 같은 에러가 나면 원격 로그인을 허용하지 않은 것이므로 환경설정에서 허용 해준다.\n\u0026#34;ssh: connect to host localhost port 22: Connection refused\u0026#34; 환경설정 \u0026gt; 공유(Sharing) \u0026gt; 원격 로그인(Remote Login)에 체크박스를 눌러준다.\n [ Troubleshooting #2 ] : Password\nPassword를 입력하라고 뜬다면 나중에 하둡 실행시 Permission denied 오류가 나므로 미리 권한을 부여해주자\nssh-keygen -t rsa -P \u0026#39;\u0026#39; -f ~/.ssh/id_rsa cat ~/.ssh/id_rsa.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys chmod 0600 ~/.ssh/authorized_keys      STEP1. 하둡 설치 #  터미널에 명령 입력\nbrew install hadoop 만약 brew가 없다면 Homebrew에 접속하여 설치해준다.\n만약 brew가 아닌 직접 설치를 원한다면 Hadoop에서 원하는 버전의 파일을 다운받고 압축을 해제해주면 설치가 완료된다.\nSTEP2. 환경변수 수정 #  ## 하둡의 버전과 설치된 경로를 확인 brew info hadoop ## 경로는 위 명령어로 확인 및 하둡 버전 X.X.X는 본인이 설치한 버전으로 수정 cd /opt/homebrew/Cellar/hadoop/3.3.2 Finder에서 저 경로가 보이지 않았지만, 터미널에서 명령어 치니 경로가 잘 들어가지긴 했다.\n그래도 직접 Finder에서 보기 위해서 Finder에서 \u0026lsquo;Cmd+Shift+G\u0026rsquo; 를 치니 경로 검색 창이 떴고 그걸로 들어가니 Finder에서 볼 수 있었다. 앞으로 수정해야할 하위 파일들은 아래 경로에 있으니 들어가준다.\ncd libexec/etc/hadoop 앞으로 수정해야 할 파일들\n(1) hadoop-env.sh (하둡 사용)\n(2) core-site.xml (Pseudo-Distributed Mode)\n(3) hdfs-site.xml (Pseudo-Distributed Mode)\n(4) mapred-site.xml (YARN)\n(5) yarn-site.xml (YARN)\n 2-1. hadoop-env.sh 변경 #  open hadoop-env.sh 파일을 열고 아래 명령어로 본인의 자바 경로를 확인 후 나온 경로를 추가해준다.\n## 자바 경로 확인 /usr/libexec/java_home ## 버전이 여러개라면 버전 특정하기 /usr/libexec/java_home -v8 export JAVA_HOME=\u0026#34;/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home\u0026#34; 아래 그림처럼 그냥 맨 마지막줄에 추가해주면 된다. 이제, 하둡 클러스터를 사용할 준비가 완료됐다.\n하둡 최상위 경로에서 아래 명령어를 치면 정상 실행되는지 확인 가능하다!\nbin/hadoop Single Node 지만 다음 3가지 모드가 지원되며 내가 사용하고 싶은 Pseudo-Distributed Mode를 위해 추가적으로 환경변수를 수정하자\n(1) Local (Standalone) Mode (2) Pseudo-Distributed Mode (3) Fully-Distributed Mode\nPseudo-Distributed Mode란? : 각 하둡 daemon이 각각의 분리된 Java 프로세스에서 실행되는 모드로, standalone 모드와 다르게 가상으로 분산시스템을 경험할 수 있다.\n2-2. core-site.xml 변경 #  open core-site.xml 파일을 열어  태그에 복사하여 넣어준다.\n\u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hdfs://localhost:9000\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 2-3. hdfs-site.xml 변경 #  open hdfs-site.xml 파일을 열어  태그에 복사하여 넣어준다.\n\u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.replication\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 이제 로컬에서 맵리듀스를 실행해 볼 수 있지만,\nYARN으로 맵리듀스 및 리소스매니저와 노드매니저 daemon 을 실행해보기 위해서 추가적으로 더 환경변수를 수정해준다.\n2-4. mapred-site.xml 변경 #  open mapred-site.xml 파일을 열어  태그에 복사하여 넣어준다.\n\u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.framework.name\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;yarn\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.application.classpath\u0026lt;/name\u0026gt; \u0026lt;value \u0026gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*\u0026lt;/value \u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 2-5. yarn-site.xml 변경 #  open yarn-site.xml 파일을 열어  태그에 복사하여 넣어준다.\n\u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.env-whitelist\u0026lt;/name\u0026gt; \u0026lt;value \u0026gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_HOME,PATH,LANG,TZ,HADOOP_MAPRED_HOME\u0026lt;/value \u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; STEP3. 하둡 실행 #  3-1. 실행 전 준비 #  ssh localhost ssh 를 한번 더 체크해보고 만약 마지막 접속 시간이 뜨지 않으면 페이지 상단에 \u0026ldquo;ssh 설치 여부 및 권한 확인\u0026quot;을 확인해보기 바란다.\n이제 HDFS 로 포맷한다.\n## 본인 하둡 경로 들어가기 cd /opt/homebrew/Cellar/hadoop/3.3.2 ## 파일시스템 포맷 hdfs namenode -format 3-2. 하둡 실행 #  cd /opt/homebrew/Cellar/hadoop/3.3.2/libexec sbin/start-all.sh # 또는 로컬에서 맵리듀스 실행 sbin/start-dfs.sh # 또는 yarn에서 맵리듀스 실행 sbin/start-yarn.sh 위 명령어를 입력해주면 정상적으로 실행된다.\n또한 맵리듀스 실행을 위해서 HDFS 디렉토리가 필요하므로 만들어둔다.\n# 경로는 하둡 최상위 경로에서 실행 # cd /opt/homebrew/Cellar/hadoop/3.3.2 bin/hdfs dfs -mkdir /user bin/hdfs dfs -mkdir /user/\u0026lt;username\u0026gt; 3-3. 실행 확인 #  jps jps 를 터미널에 입력해주면, 하둡이 정상 설치 및 실행되고 있음을 아래와 같이 보여준다.\n35906 DataNode 36274 NodeManager 38132 SecondaryNameNode 38456 Jps 35800 NameNode 36175 ResourceManager 그럼 이제 localhost 로 접속해서 확인해보자\n Cluster status : http://localhost:8088\nHDFS status : http://localhost:9870\nSecondary NameNode status : http://localhost:9868\n [ 실행 화면 예시 ]\nYarn HDFS status Secondary NameNode status  3-4. 실행 종료 #  ## 만약 경로가 하둡 최상단 경로가 아니라면 다시 들어가준다. ## 하지만 해당 경로에서 ./start-all.sh 로 실행 해 줬기 때문에 ## 그냥 아래 ./stop-all.sh만 실행해주면 된다. sbin/stop-all.sh # 또는 sbin/stop-dfs.sh # 또는 sbin/stop-yarn.sh Reference #  Hadoop: Setting up a Single Node Cluster\nInstalling Hadoop on a Mac\nmacOS에서 Hadoop 설치하기\n"},{"id":10,"href":"/docs/ETC/Hugo/first_hugo_blog/","title":"초보자 Hugo 블로그 구축기","section":"Hugo","content":"초보자 Hugo 블로그 구축기 #  구축 환경\n OS : MacOS Catalina 10.15.7\n Hugo란? #  : Go 언어로 쓰여진 \u0026lsquo;정적 웹사이트 생성기\u0026rsquo;(Static site generator) 라고 한다.\nGo 언어란? : 구글에서 발표한 언어로, 파이썬 같은 스크립트 언어가 아닌 컴파일 언어이다.\n정적 웹사이트란? (Static site) :\n 말 그대로 웹사이트가 \u0026lsquo;정적\u0026rsquo;(Static)인 사이트이다.\n하지만 항상 고정된 화면을 보여준다기 보다는 접속시마다 서버가 새로 정보를 업데이트하는지에 따라 동적 사이트와 구분할 수 있겠다. 정적이지 않은(Dynamic) 웹사이트의 대표적인 예로는 유튜브, 네이버 등 이 있다. 정적인 웹사이트의 구축은 그렇지 않은 사이트보다 더 구축하기 쉽고 빠르다는 장점이 있다.\n→  따라서 Hugo는 이런 정적 사이트를 만들어 줄 수 있는 생성기라고만 이해하고 넘어갔다. 자세한건 아래 영상에 아주 쉽게 소개가 되어 있으니 시청을 추천한다.\n얄팍한 코딩 사전 : 정적 웹은 뭐고 동적 웹은 뭔가요?  그렇다면 왜 Hugo 를 선택했는가?\n 사실 큰 이유는 없다 ㅎㅎ 그냥 일반적으로 많이 쓰이는 것으로 보이는 Jekyll보다 사이트 생성이 빠르다고 하였고 Go언어를 공부해보고자 하는 사람들이 많이 시도해 본 것으로 보인다. 어차피 제로 베이스로 시작하는거, 나에겐 Jekyll이나 Hugo나 외계어로 보이는건 똑같았다.  자 이제 생성을 시작해보자!\nSTEP1. Hugo 설치 #  나는 맥북이므로 brew를 활용하여 설치하였다. brew 가 없다면 brew 에서 설치한다.\n$ brew install hugo ## 설치 후 버전 확인으로 설치가 잘 됐는지 확인해보자 $ hugo version 윈도우이거나 brew 이외의 설치 방법은 Hugo 공식 사이트인 https://gohugo.io/getting-started/quick-start/ 나 하단 Reference의 블로그들을 참고해주시길 바란다.\nSTEP2. Hugo 블로그 폴더 생성 #  쉽게 생각하면 앞으로 블로그에 올라갈 콘텐츠들이나 테마 등 블로그에 관한 모든 것이 담기는 폴더라고 생각하면 된다.\n## 폴더 이름은 마음대로 지정해도 된다. ## 나는 blog라고 지었는데 변경을 원하면 blog 대신 다른 이름을 쓰면 된다. $ hugo new site blog 원하는 경로에서 생성해주면 되며\n생성 되면 Hugo site가 생성됐다며 아래와 같은 메세지가 출력된다!\nCongratulations! Your new Hugo site is created in /Users/내이름/blog. Just a few more steps and you\u0026#39;re ready to go: ** 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 앞서 생성한 blog 폴더에 들어가면 아래와 같은 기본적인 구조가 생성되어 있다.\nSTEP3. 테마 추가하기 #  나는 다른 분들이 이쁘게 만들어주신 테마를 사용할 것이다.ㅎㅎ\nhugo theme 사이트 : themes.gohugo.io\n내가 선택한 테마 : https://themes.gohugo.io/hugo-book/\n Hugo 버전이 최신 버전 이어야하면 upgrade 해준다.  ## 버전 확인 ; 테마에서 요구하는 버전보다 하위 버전이라면 upgrade 필요하다. $ hugo version ## (참고) 나는 brew로 간단하게 upgrade 해줬다. $ brew upgrade hugo 이제 내가 고른 테마를 다운 받자!\n테마의 github : hhttps://github.com/alex-shpak/hugo-book.git\n## 우선, STEP2에서 만든 blog 경로로 들어가자 $ cd blog ## 테마 다운로드 $ git init $ git submodule add https://github.com/alex-shpak/hugo-book.git themes/book 이제 아까 blog 폴더 내에 themes에 들어가보면 \u0026lsquo;book\u0026rsquo; 폴더가 생긴 것을 볼 수 있다.\n그 다음, 보통 글을 한개를 써서 올려보라는데 사실 나는 어떻게 해야하는지 감이 없어서 애를 먹었더랬다.\n뒤에 할 터이니 우선 다음 step으로 넘어가자!\nSTEP4. Github 저장소 생성 #  https://gohugo.io/hosting-and-deployment/hosting-on-github/\nGithub 저장소 2개를 생성 해야 한다.\n 하나는 블로그 컨텐츠 저장소 생성 (blog) 다른 하나는 렌더링된 웹사이트를 담을 저장소 (key4920.github.io)  요약하자면 레파지토리를 2개 생성해야하고, 2번인 웹사이트를 담을 저장소는 이름을 github.io 로 지어야 한다. \u0026lt; Troubleshooting #1 \u0026gt;\n2번 저장소의 USERNAME 부분이 내 id 이어야 한다는 것을 무시하고 내 마음대로 지어보려 했다가 자꾸 에러가 났었다.\n반드시 본인의 github id로 생성해 주어야한다. 바꿀 수 있는 것 같지만, 나중에 시간이 남으면 시도해 보도록하고, 패스한다.\n 두개 모두 이미 가지고 있으므로 already exists라고 뜨지만 그냥 저렇게 생성해주면 된다.\n1번 저장소인 \u0026lsquo;blog\u0026rsquo;를 내가 처음에 만들었던 \u0026lsquo;blog\u0026rsquo; 폴더랑 연동 해 주고\n2번 저장소인 \u0026lsquo;key4920.github.io\u0026rsquo;를 submodule로 등록 해 준다.\n## 우선 처음 만들었던 blog 폴더로 이동 (이미 들어와 있으면 패스) cd blog ## git 연동 $ git init $ git remote add origin https://github.com/key4920/blog.git $ git submodule add -b main git@github.com:key4920/key4920.github.io.git public \u0026lt; Troubleshooting #2 \u0026gt;\n blog remote할 때 Permission denied (publickey).에러가 났다.   잘 모르지만 github 주소를 \u0026lsquo;https\u0026rsquo; \u0026lsquo;ssh\u0026rsquo; 중에 \u0026lsquo;https\u0026rsquo; 주소로 하니 해결됐고  key4920.github.io submodule 할 때는 Unable to checkout submodule ‘public’ 에러가 났다.   얘는 \u0026lsquo;ssh\u0026rsquo; 주소로 하니 됐다\u0026hellip; 왜인지는 모르겠다\u0026hellip;   STEP5. 예시 사이트 보기 #  아까 언급했듯이, 막상 글을 쓰려니 어떻게 해야하는지 막막했다.\n그런데 보통 themes/book 폴더 내에 들어가보면 \u0026lsquo;exampleSite\u0026rsquo; 폴더가 있다.\n\u0026lsquo;exampleSite\u0026rsquo; 폴더 안에 있는 모든 폴더 및 파일들을 복사해서 blog 폴더 안에 덮어쓰기 해준다.\n 이때 내가 고른 테마의 exampleSite 안에는 \u0026lsquo;config.yaml\u0026rsquo; 파일이 있는데\n이건 기본적으로 생성되어 있던 \u0026lsquo;config.toml\u0026rsquo; 파일과 동일한 것이지만 파일 확장자가 달라서 \u0026lsquo;덮어쓰기\u0026rsquo;가 안됐으므로 \u0026lsquo;config.toml\u0026rsquo; 파일은 삭제 해 줬다.  $ hugo server -D 입력해주면 아래와 같은 문구와 함께 http://localhost:1313/ 에 접속하라고 뜨는데, 이 url은 내 사이트를 build하기 전 예시로 보여주는 기능이다.\n웹에 이 url을 복붙해서 들어가면 현재 내 blog의 예시 사이트를 볼 수 있다.\n나 같은 초보자들은 이제 exampleSite에서 복붙했던 content 내의 예시 글들을 참고해서 blog 내의 구조를 익히면 된다.\n내가 고른 테마 같은 경우엔, 블로그에 올라가는 일반적인 글 경로는 blog/content/docs/콘텐츠 에 있었다. 자세한 구조는 본인이 선택한 테마의 설명을 참고해야한다.\n여태까지는 blog 폴더 안에 어느 형식으로 어떤 구조로 콘텐츠를 넣으면 어떻게 보이는지를 살펴보았다. 하지만, 실제 내 블로그 url인 key4920.github.io 를 입력해서 들어가도 사이트가 build 된 상태가 아니다.\n앞의 http://localhost:1313/ 에서 결과가 맘에 들면 git 업로드 해줘야 실제 내 블로그에 적용된다.\nSTEP6. 사이트에 글 업로드 #  blog 폴더에 들어가서 \u0026lsquo;deploy.sh\u0026rsquo; 파일을 하나 생성하고 파일 안에 아래 내용을 복붙해서 저장해준다.\n 이때 hugo -t book 부분에서 \u0026lsquo;book\u0026rsquo;을 본인 테마 이름으로 수정 해 준다.  #!/bin/sh # If a command fails then the deploy stops set -e printf \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\u0026#34; # Build the project. ####### 이부분을 본인 테마로 변경해주세요~ ####### hugo -t book # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin main cd .. # anyblogname 업데이트 git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push origin main 원래는 이 파일 안에 한줄 한줄을 터미널에서 매번 실행 해 주어야하지만, 귀찮으므로 이런 파일을 만들고 파일만 실행하면 안의 코드가 실행되게 하는 원리이다.\n이제 이 파일을 실행해보자!\n## 뒤에는 그냥 커밋 메시지이다. $ ./deploy.sh \u0026#34;message\u0026#34; \u0026lt; Troubleshooting #3 \u0026gt;\n이때 나는 권한이 없다며 에러가 났다. 아래 코드로 권한 지정해주자\n또한 가끔 내가 변경한 파일이 untracked file이어서 Github로 push가 안 된다.\n이럴 때는 위의 deploy.sh 파일 내의 코드들을 한줄씩 직접 실행 해 본다.\n## 권한 에러 있었다면 지정 chmod +x deploy.sh 그래도 혹시 권한 에러가 난다면, System Preferences \u0026gt; Security \u0026amp; Privacy \u0026gt; Privacy \u0026gt; Full Disk Access 에 Terminal 을 추가해준다. 나같은 경우는 그래도 권한 에러가 났다. 그래서 아래 코드로 해결했다.\n$ xattr -l deploy.sh ## 프린트 된 것 com.apple.quarantine 이 있다면 아래 명령어로 삭제 $ xattr -d com.apple.quarantine deploy.sh ## 삭제 ## 다시 권한 부여 후 파일 실행 $ chmod +x deploy.sh $ ./deploy.sh \u0026#34;message\u0026#34;    앞으로 블로그 업데이트에 필요한 일 #   content 폴더 내에 마크다운 형식으로 글 파일 넣거나 (자세한 경로는 본인 테마마다 상이할 수 있습니다.) config 등 다른 파일 customising 콘텐츠 업로드에 필요한 코드  ## 본인 hugo blog 폴더 들어가기 $ cd blog ## (옵션) 예시 사이트를 보는 것이므로 옵션 $ hugo server -D ## 빠져나오려면 Ctrl + C $ ./deploy.sh \u0026#34;commit message\u0026#34;  추가 기능 #   config 파일에서 원하는대로 이것저것 변경 해준다.  DefaultContentLanguage: ko 로 언어도 수정해주고 favicon이나 이미지도 넣어주는 등 다양하게 커스터마이징 해 준다!   구글이나 네이버, 다음에 글이 검색 될 수 있도록 노출 시키는 기능 추가 또는 구글 애드센스 넣기 댓글 기능 넣기  등 다양하게 기능을 넣어 본인의 블로그를 구축해 나갈 수 있다~\n앞으로 다른 글에서 다뤄보도록 하겠다.\n Reference #  https://gohugo.io/getting-started/quick-start/\nhttps://gohugo.io/hosting-and-deployment/hosting-on-github/\nhttps://github.com/Integerous/Integerous.github.io\nhttps://hoontaeklee.github.io/20191229_blogging_with_hugo/#2-unable-to-checkout-submodule-public\n"},{"id":11,"href":"/docs/bigdata_platform/ApacheSpark/spark_install/","title":"Mac OS에 스파크3 설치 및 pyspark 시작","section":"Apache Spark","content":"Mac OS에 스파크3 설치 및 pyspark 시작 #  설치 환경\n OS : MacOS Catalina 10.15.7\nJava : java 11.0.1\nPython : Python 3.7.6\nSpark : spark 3.0.1\n STEP1. 스파크 버전 선택 후 다운로드 #  NT. Java 와 Python은 설치 돼 있다는 가정으로 진행한다.\n스파크 다운로드 사이트 링크 : Downloads | Apache Spark\n사이트에 접속하면 아래 화면이 나오게 된다.\n원래는 Spark 2.4.7 을 선택해서 설치했었다.\n하지만 로컬의 Java 버전이 11이었으므로, 그냥 이참에 Spark3.0을 시도해보기로 했다!\n(참고) Spark3.0은 Java 11을 지원하고, Spark2.X는 Java 8을 지원한다.\n우선 원하는 Spark 버전 선택하여 \u0026lsquo;Download Spark\u0026rsquo; 를 클릭해주면 다음과 같은 화면으로 넘어간다.\nmirror sites 중 한개를 선택해 다운로드 해주는데, 그냥 최상단 링크를 눌러 다운로드 해준다.\nSTEP2. 다운로드한 압축 파일을 home directory에 풀어준다. #  tar -zxvf spark-3.0.1-bin-hadoop3.2.tar STEP3. ~/.bash_profile 환경변수 수정 #  어떤 directory에서도 spark notebook 열 수 있도록 환경변수 설정해준다.\n## .bash_profile 있는지 확인 ls -a ## .bash_profile 파일 열기 nano .bash_profile ## 또는  vi .bash_profile 아래 환경변수 추가로 써준다.\n## 버전 맞게 써주기 export SPARK_PATH=~/spark-3.0.1-bin-hadoop3.2 ## PySpark Shell을 주피터 노트북에서 열 수 있도록 설정 export PYSPARK_DRIVER_PYTHON=\u0026#34;jupyter\u0026#34; export PYSPARK_DRIVER_PYTHON_OPTS=\u0026#34;notebook\u0026#34; ## 파이썬 3를 사용한다면 아래 설정 추가해 주어야 에러가 나지 않음 export PYSPARK_PYTHON=python3 ## sparknb는 명령어 마음대로 써준 것이므로, 원하는 이름으로 수정 가능 ## local[2] 는 로컬 코어 2개를 사용한다는 뜻으로 본인 로컬 환경에 맞게 수정 가능 alias sparknb=\u0026#39;$SPARK_PATH/bin/pyspark --master local[2]\u0026#39; 만약 nano .bash_profile 했었으면 ^x —\u0026gt; Y —\u0026gt; enter 로 저장하고 빠져나오기\nvi .bash_profile 했었으면 :wq 입력 후 저장하고 빠져나오기\nsource .bash_profile STEP4. 실행 확인 #  spark-shell 실행 #  ## 터미널에서 spark-shell 입력하여 스파크 쉘 실행 spark-shell 터미널에 spark-shell 입력하면 아래와 같이 정상적으로 실행되면서 스칼라를 통해 코드를 작성할 수 있다.\n주피터 노트북에서 실행 #  ## 터미널에서 sparknb입력하여 주피터 노트북 실행 ## 위에서 alias 다른 이름으로 설정했다면, 해당 이름으로 실행 sparknb 명령어 입력하면 주피터 노트북이 켜지고, pyspark를 작성할 수 있다.\nSTEP 5. 이제 모두 완료됐으니, 간단한 실습해보자! #  주피터 노트북에서 파이썬 코드 작성 #  # Reason why we have the getOrCreate code # http://stackoverflow.com/questions/28999332/how-to-access-sparkcontext-in-pyspark-script sc = SparkContext.getOrCreate() import numpy as np TOTAL = 1000000 dots = sc.parallelize([2.0 * np.random.random(2) - 1.0 for i in range(TOTAL)]).cache() print(\u0026#34;Number of random points:\u0026#34;, dots.count()) stats = dots.stats() print(\u0026#39;Mean:\u0026#39;, stats.mean()) print(\u0026#39;stdev:\u0026#39;, stats.stdev()) Number of random points: 1000000 Mean: [-0.00076914 0.00090079]\nstdev: [0.57721218 0.57750566]\ndots.collect()[:5] ## 형식 구경하기 [array([0.71638614, 0.34966844]),\narray([0.85926697, 0.43265725]),\narray([-0.12204166, -0.8161978 ]),\narray([-0.96733469, -0.57462963]),\narray([-0.13704113, -0.48361848])]\ndots ParallelCollectionRDD[0] at readRDDFromFile at PythonRDD.scala:262\n%matplotlib inline from operator import itemgetter from matplotlib import pyplot as plt plt.figure(figsize = (10, 5)) # Plot 1 plt.subplot(1, 2, 1) plt.xlim((-1.0, 1.0)) plt.ylim((-1.0, 1.0)) sample = dots.sample(False, 0.01) X = sample.map(itemgetter(0)).collect() Y = sample.map(itemgetter(1)).collect() plt.scatter(X, Y) # Plot 2 plt.subplot(1, 2, 2) plt.xlim((-1.0, 1.0)) plt.ylim((-1.0, 1.0)) inCircle = lambda v: np.linalg.norm(v) \u0026lt;= 1.0 dotsIn = sample.filter(inCircle).cache() dotsOut = sample.filter(lambda v: not inCircle(v)).cache() # inside circle Xin = dotsIn.map(itemgetter(0)).collect() Yin = dotsIn.map(itemgetter(1)).collect() plt.scatter(Xin, Yin, color = \u0026#39;r\u0026#39;) # outside circle Xout = dotsOut.map(itemgetter(0)).collect() Yout = dotsOut.map(itemgetter(1)).collect() plt.scatter(Xout, Yout) \u0026lt;matplotlib.collections.PathCollection at 0x7f88920d0a50\u0026gt;\nReference #  Install Spark on Mac (PySpark)\n[mac] Apache Spark Study -1 ( Spark설치(HomeBrew) )\napache-spark@3.0.1 설치\n"}]